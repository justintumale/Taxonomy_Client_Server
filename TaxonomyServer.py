import socket
import pickle

driverLoop = True
order_list = []


def parse_command(path):
    """Parse an input path and return the command.

    Keyword arguments:
    path -- the user's input string
    """
    path = path.split(' ', 1)
    path = path[0]
    return path


def parse_path_to_list(path):
    """Parse an input path and append each taxonomy level into an array.

    Keyword arguments:
    path -- the user's input string
    """
    if path is None:
        return None
    else:
        path = path.split(' ', 1)
        if len(path)>1:
            path = path[1]
            path = path.split('/')
            return path
        elif path[0] == 'list':
            path = [' ']
            return path
        elif path[0] == 'quit':
            path = [' ']
            return path


class Taxonomy:
    """Taxonomy represents a Linnean category (order, family, or genus)
    If a Taxonomy object's level is 'genus', then its item list contains
    strings of the form <species-name> [(<common-name>)]
    If the Taxonomy object's level is 'Order' or 'Family', then its item
    list contains Taxonomy objects of the next level down.

    Attributes:
        driver_loop         A boolean object that triggers an exit from the server when the
                            client inputs 'quit'.
        itemList            A list that contains the current category's sub-taxonomies.
        categoryName        The name of the level's category.
        level               The level of this taxonomy (Order, Family, Genus, or Species).
        error_message       A string that will contain the error message to be sent to the user.
        path                The path inputed by the user.
    """

    driver_loop = True
    itemList = None
    categoryName = ''
    level = ''
    error_message = ''
    path =''

    def __init__(self, category, level='Order'):
        """
        Create a new Taxonomy based on 'category'
        if 'level' is 'Order' and a serialization file
        for this order exists, then populate this object from
        that file; otherwise, create an empty Taxonomy

        :param category: the name of an order, a family, or a genus
        :param level: one of 'Order', 'Family', or 'Genus'
        """
        self.itemList = []
        self.categoryName = category
        self.level = level
        if level == 'Order':
            order_list.append(self)

    def addSpecies(self, species):
        """
        Add a species to this taxonomy.

        :param species: The name of the species to be added to the taxonomy.
        :return: True if the level of this taxonomy is 'Genus'.  Else, return
                False.
        """
        self.itemList.append(species)

    def addTaxonomy(self, subTaxonomy):
        """
        Add a sub-taxonomy to this taxonomy and return True. The sub-taxonomy must
        be at one level below this taxonomy. If not, set an error message and return False.
        :param subTaxonomy: The sub-taxonomy to be added to the current taxonomy.
        :return: False if the sub-taxonomy to be added is not one-level below the current taxonomy.
        """
        if self.level == 'Order' and subTaxonomy.level != 'Family':
            return False
        elif self.level == 'Family' and subTaxonomy.level != 'Genus':
            return False
        else:
            self.itemList.append(subTaxonomy)

    def errorMessage(self):
        """
        :return: Return the error message generated by the last insertion, or
        'Insertion OK' if the last insertion did not create an error
        """
        return self.error_message

    def insert_species(self, order, family, genus, species, level, error_message, itemList):
        """
        Helper function for insert(path).  This is the operation that is done when the
        highest level being inserted is species.

        :param order:           the upper taxonomy's order name.
        :param family:          the upper taxonomy's family name.
        :param genus:           this taxonomy's genus name.
        :param species:         the species to be inserted into this taxonomy
        :param level:           the level of this taxonomy.
        :param error_message:   the error message to be returned to the user.
        :param itemList:        the current taxonomy's sub-taxonomies.
        :return:                False if the current level is not 'Genus'.
        """

        if self.level == 'Family' or self.level == 'Order':
            self.error_message = 'Error inserting ' + species + ' into ' + self.categoryName + ': wrong length'
            self.error_message
            return False

        if len(itemList) != 0:
                #if the species already belongs to this taxonomy, do nothing
                for entry_species in itemList:
                    if species == entry_species:
                        break
                #if there is no specie in this taxonomy's sub-taxonomy that matches the
                #input specie, append it to the list
                else:
                    itemList.append(species)

        else:
            itemList.append(species)

    def insert_genus(self, order, family, genus, species, level, error_message, itemList):
        """
        Helper function for insert(path).  This is the operation that is done when the
        highest level being inserted is genus.

        :param order:           the upper taxonomy's order name.
        :param family:          this taxonomy's family name.
        :param genus:           the genus to be inserted into this taxonomy.
        :param species:         the species to be inserted into this taxonomy
        :param level:           the level of this taxonomy.
        :param error_message:   the error message to be returned to the user.
        :param itemList:        the current taxonomy's sub-taxonomies.
        :return:                False if the current level is not 'Family'.
        """

        if self.level != 'Family':
            self.error_message = 'Error inserting ' + genus + '/' + species + ' into ' + self.categoryName + ': wrong length'
            self.error_message
            return False

        if len(itemList) != 0:
                for entry_genus in itemList:
                #if the genus already belongs to this taxonomy, insert the species into this genus
                    if entry_genus.categoryName == genus:
                        entry_genus.insert(species)
                        break
                #if there is no genus in this taxonomy's sub-taxonomy that matches the
                #input genus, append it to the list of genuses and then insert the input genus
                #and input species into this taxonomy
                else:

                    itemList.append(Taxonomy(genus, 'Genus'))
                    self.insert(genus + '/' + species)
        else:
             itemList.clear()
             itemList.append(Taxonomy(genus, 'Genus'))
             itemList[0].insert(species)


    def insert_family(self, order, family, genus, species, level, error_message, itemList):
        """
        Helper function for insert(path).  This is the operation that is done when the
        highest level being inserted is family.

        :param order:           this taxonomy's order name.
        :param family:          the family to be inserted into this taxonomy.
        :param genus:           the genus to be inserted into this taxonomy.
        :param species:         the species to be inserted into this taxonomy
        :param level:           the level of this taxonomy.
        :param error_message:   the error message to be returned to the user.
        :param itemList:        the current taxonomy's sub-taxonomies.
        :return:                False if the current level is not 'Order'.
        """

        if self.level != 'Order':
            self.error_message = 'Error inserting ' + family + '/' + genus + '/' + species + ' into ' + self.categoryName + ': wrong length'
            self.error_message
            return False

        if len(itemList) != 0:         #if entry exists

                for entry_family in itemList:
                #if the family already belongs to this taxonomy, insert the genus and species into that family
                    if family == entry_family.categoryName:
                        entry_family.insert(genus + '/' + species)
                        break

                #if there is no family in this taxonomy's sub-taxonomy that matches the
                #input family, append it to the list of families and then insert the input family, input genus
                #and input species into this taxonomy
                else:
                    #append the current branch
                    itemList.append(Taxonomy(family, 'Family'))
                    #insert the first branch
                    self.insert(family +'/' + genus + '/' + species)

        else:                                                   #if no entry exists
             itemList.append(Taxonomy(family, 'Family'))
             itemList[0].insert(genus + '/' + species)

    def insert_order(self, order, family, genus, species, level, error_message):
        """
        Helper function for insert(path).  This is the operation that is done when the
        highest level being inserted is the order.

        :param order:           the order to be inserted into this taxonomy
        :param family:          the family to be inserted into this taxonomy.
        :param genus:           the genus to be inserted into this taxonomy.
        :param species:         the species to be inserted into this taxonomy
        :param level:           the level of this taxonomy.
        :param error_message:   the error message to be returned to the user.
        """

        if self.level == 'Family' or self.level == 'Genus' or self.level == 'Species':
            self.error_message = 'Error inserting ' + order + '/' + family + '/' + genus + '/' \
                                 + species + ' into ' + self.categoryName + ': wrong length'
            self.error_message
            return False

        if len(order_list) != 0:
                #if the order belongs to the taxonomy already, insert the family, genus,
                #and species into that order
                for entry_order in order_list:
                    if order == entry_order.categoryName:
                        entry_order.insert(family + '/' + genus + '/' + species)
                        break

                #if there is no order in this taxonomy's sub-taxonomy that matches the
                #input family, append it to the list of orders
                else:
                    order_list.append(Taxonomy(order, 'Order'))
                    #if the order in the list of orders matches the input order,
                    #insert the input family, input genus, and input species into
                    #that order
                    for order_entry in order_list:
                        if order_entry.categoryName == order:
                            order_entry.insert(family + '/' + genus + '/' + species)
        else:
            order_list.append(Taxonomy(order, 'Order'))
            order_list[0].insert(family + '/' + genus + '/' + species)


    def insert(self, path=None):
        """
        Insert the species that is the last element of 'path' into
        this object,creating order, family, or genus Taxonomy objects
        as needed. If the length of path does not match the level of this
        Taxonomy object, set an error message ,abort the insertion,  and
        return False; otherwise return True after successful insertion.

        This Taxonomy Level  Expected path length
        Order                3
        Family               2
        Genus                1

        path: front-slash-separated list of categories.

        :param path: the path of the user's input.
        :return: True if successful, otherwise return False.
        """
        #parse the path into the level_ array
        level_ = []
        for i in path.split('/'):
            level_.append(i)

        order = ''
        family = ''
        genus = ''

        # level Genus
        # inserting species
        if len(level_) == 1:
            species = str(level_[0])

            result = self.insert_species(order, family, genus, species, self.level, self.error_message, self.itemList)
            if result == False:
                return False

        # level Family
        # inserting genus/species
        elif len(level_) == 2:
            genus = str(level_[0])
            species = str(level_[1])

            result =  self.insert_genus(order, family, genus, species, self.level, self.error_message, self.itemList)
            if result == False:
                return False

        # level Order
        # inserting family/genus/species
        elif len(level_) == 3:
            family = str(level_[0])
            genus = str(level_[1])
            species = str(level_[2])

            result = self.insert_family(order, family, genus, species, self.level, self.error_message, self.itemList)
            if result == False:
                return False

        #level TOPs
        #inserting order/family/genus/species
        elif len(level_) == 4:
            order = str(level_[0])
            family = str(level_[1])
            genus = str(level_[2])
            species = str(level_[3])
            result = self.insert_order(order, family, genus, species, self.level, self.error_message)
            if result == False:
                return False

        else:
            self.error_message = False
            self.error_message
            return 'False'

        self.error_message = 'Insertion OK'
        self.error_message
        return 'True'

    def list(self):
        """
        Return a string representing the contents of this Taxonomy
        and its sub-Taxonomies, in the format
        top-category-name (subitem1, subitem2,...),
        where subitem1, subitem2... are either strings representing species,
        in the  form <latin-name> [(common-name)], or sublists representing
        Taxonomies.
        """
        my_list = []

        for entry in self.itemList:
                #if the entry in the taxonomy's sublevel is a string type, append
                #the entry to list
                if isinstance(entry, str):
                    my_list.append(entry)
                #if the entry is not of a string type, recursively call the list
                #function on it while adding it to the list
                else:
                    my_list.append(entry.list())

        string = self.processList(my_list)

        return self.categoryName + ' (' + string + ')'

    def processList(self, list):
        """
        Helper function for list that puts commas in between the contents
        of a substring.

        :param list: an array of Taxonomy categories
        :return: a string in the proper format with commas in between the items
        """

        if len(list) == 0:
            return 'No entries found'
        if len(list) == 1:
            return list[0]
        else:
            processed_string = ''
            #if this item in the list is not the first item, add a comma before it
            #and then add it to the processed string
            for item in list[1:]:
                processed_string = processed_string + ', ' + item
            #finally add the first item of the list to the processed string, without
            #the comma before it.
            processed_string = list[0] + processed_string

            return processed_string

    def quit(self):
        """
        Exits the user out of the server.
        """
        self.driver_loop = False

    def serialize(self):
        """
        Save contents of this object using pickle.
        """
        output = open('tax_save.pkl', 'wb')
        pickle.dump(self, output)
        output.close()

    def open(self):
        """
        Open the contents of a pickle file.
        """
        order = Taxonomy('')
        inputFile = open('tax_save.pkl', 'rb')
        order = pickle.load(inputFile)
        inputFile.close()
        return order


def search(category_name, list_ = None):
    '''
    Determine whether or not a category is in the taxonomy tree.

    :param category_name: the name that is being searched
    :param list_: the subtree that is being searched
    :return: If found, return True.  Otherwise return False.
    '''
    for entry in list_:
        #if the entry in the list is a species (string type), check if it
        #matches the name being searched
        if isinstance(entry, str):
            #if they match, return true
            if entry == category_name:
                return 'Found'
        else:
            #if the entry is not a string, check its category name and see
            #if theres a match.  If theres a match, return true.
            if entry.categoryName == category_name:
                return 'Found'
            else:
            #if there's no match, search the entry's subtree.
                return search(category_name, entry.itemList)
    else:
        return 'Not Found'



def Main():
    host = socket.gethostname()
    port = 5000
    '''set up UDP socket'''
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    '''bind socket to port'''
    s.bind((host, port))
    print("Server started")
    new_order = Taxonomy('')

    while driverLoop:
        #UDP is connectionless. Store the data and the address that the data came from
        data, address = s.recvfrom(2024)
        data = data.decode('utf-8')

        #   parse the command from the input
        new_data = ''
        command = parse_command(data)
        path_list = parse_path_to_list(data)

        #   if the input is insert
        if command == 'insert':
                if path_list is None:
                    new_data = 'Error. Please insert using this format: "insert order/family/genus/species (common name)" '
                elif len(path_list) == 4:
                    #if the order in the list of orders matches the order input, insert the taxonomy into
                    # that order and then serialize the result
                    for order_entry in order_list:
                        if path_list[0] == order_entry.categoryName:
                            new_data = new_order.insert(path_list[0] + '/' + path_list[1] + '/'
                                                        + path_list[2] + '/' + path_list[3])
                            new_order.serialize()
                            break
                    #otherwise, create a new taxonomy object with that order and then insert its taxonomy
                    else:
                        new_order = Taxonomy(path_list[0])
                        new_data = new_order.insert(path_list[0] + '/' + path_list[1] + '/'
                                                    + path_list[2] + '/' + path_list[3])
                        new_order.serialize()
                else:
                    new_data = 'Error. Please insert using this format: "insert order/family/genus/species (common name)" '

        #   if the command is 'list', call the list function
        elif command == 'list':

            new_data = new_order.list()

        #   if the command is 'quit', call the quit function
        elif command == 'quit':
            quit()

        elif command == 'search':
            print(path_list[0])
            print(order_list[0].categoryName)
            new_data = search(path_list[0], new_order.itemList)

        else:
            new_data = 'Please enter a command in the right format.'

        #print("Sending: " + new_data)
        new_data = str(new_data)
        s.sendto(new_data.encode('utf-8'), address)
    s.close()

if __name__ == '__main__':
    Main()

